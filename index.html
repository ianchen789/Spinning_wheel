<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生日轉轉樂</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            overflow-x: hidden;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.2em;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1000px;
        }

        .panel {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            flex: 1 1 300px;
            min-width: 280px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .wheel-panel {
            flex: 1 1 400px;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        #wheelCanvas {
            width: 100%;
            max-width: 400px;
            height: auto;
            aspect-ratio: 1 / 1; /* 保持正方形 */
            border: 5px solid #3498db;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            background-color: #ecf0f1;
            transform: rotate(0deg); /* 確保一個初始的 transform 值 */
        }

        .spin-button {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #28a745;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .spin-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
        }

        .spin-button:active {
            background-color: #1e7e34;
            transform: translateY(0);
        }

        .spin-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .entry-list {
            margin-top: 15px;
            width: 100%;
        }

        .entry-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #eee;
            gap: 8px;
            font-size: 0.95em;
        }

        .entry-item label {
            min-width: 35px;
            font-weight: bold;
            color: #555;
            white-space: nowrap;
        }

        .entry-item input[type="number"] {
            flex: 1;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 60px;
            max-width: 70px;
        }

        .entry-item input[type="text"] {
            flex: 3;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .entry-item button {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .entry-item button:hover {
            background-color: #c0392b;
        }

        .add-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s ease;
            width: 100%;
        }

        .add-button:hover {
            background-color: #2980b9;
        }

        /* 指針樣式 */
        .pointer {
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 25px solid #e74c3c;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .settings-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .settings-item {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95em;
        }

        .settings-item label {
            font-weight: bold;
            color: #555;
            min-width: 70px;
        }

        .settings-item input[type="number"] {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 80px;
        }

        /* 彩帶動畫 */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            animation: confetti-fall 3s forwards ease-out;
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotateZ(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotateZ(720deg);
                opacity: 0;
            }
        }

        /* 轉盤動畫的CSS */
        #wheelCanvas.spinning {
            transition: transform var(--spin-duration) cubic-bezier(0.1, 0.5, 0, 1);
            transform: rotate(var(--end-rotation));
        }
        
        /* 彈出結果視窗 */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            text-align: center;
            position: relative;
            max-width: 90%;
            transform: scale(0.8);
            opacity: 0;
            animation: modal-fade-in 0.3s forwards ease-out;
        }

        @keyframes modal-fade-in {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: #333;
            text-decoration: none;
        }

        .modal-title {
            font-size: 2.5em;
            color: #28a745;
            margin-bottom: 15px;
        }

        .modal-result-text {
            font-size: 3.5em;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 25px;
            word-wrap: break-word;
            max-width: 100%;
        }

        .modal-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .modal-button:hover {
            background-color: #2980b9;
        }

        /* 媒體查詢：針對小螢幕設備進一步調整 */
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
                margin-bottom: 20px;
            }
            .container {
                flex-direction: column;
                gap: 15px;
            }
            .panel {
                padding: 15px;
                flex: 1 1 auto;
                max-height: none;
                overflow-y: visible;
            }
            .wheel-panel {
                min-width: 280px;
            }
            #wheelCanvas {
                max-width: 300px;
            }
            .spin-button {
                padding: 10px 20px;
                font-size: 16px;
            }
            .entry-item {
                font-size: 0.9em;
                padding: 6px 10px;
            }
            .entry-item input[type="number"] {
                width: 50px;
            }
            .pointer {
                border-left: 10px solid transparent;
                border-right: 10px solid transparent;
                border-top: 20px solid #e74c3c;
                top: 10px;
            }
            .modal-content {
                padding: 25px;
            }
            .modal-title {
                font-size: 2em;
            }
            .modal-result-text {
                font-size: 3em;
            }
        }
    </style>
</head>
<body>

    <h1>自訂轉盤應用程式</h1>

    <div class="container">
        <div class="panel controls-panel">
            <h2>轉盤區域設定</h2>
            <div id="entries" class="entry-list">
                </div>
            <button class="add-button" onclick="addEntry()">+ 新增區域</button>

            <div class="settings-section">
                <h2>額外設定</h2>
                <div class="settings-item">
                    <label for="spinCount">旋轉圈數:</label>
                    <input type="number" id="spinCount" value="5" min="1">
                </div>
                <div class="settings-item">
                    <label for="spinDuration">旋轉時間 (秒):</label>
                    <input type="number" id="spinDuration" value="5" min="1" step="0.5">
                </div>
            </div>
        </div>

        <div class="panel wheel-panel">
            <div style="position: relative;">
                <canvas id="wheelCanvas" width="500" height="500"></canvas>
                <div class="pointer"></div>
            </div>
            <button class="spin-button" id="spinButton">旋轉！</button>
        </div>
    </div>

    <div class="confetti-container" id="confettiContainer"></div>

    <div id="resultModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <div class="modal-title">恭喜您！</div>
            <div id="finalResultText" class="modal-result-text"></div>
            <button class="modal-button" onclick="closeModal()">確認</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        let centerX, centerY, radius;

        function setCanvasDimensions() {
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;

            if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
            }
            
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            radius = Math.min(centerX, centerY) * 0.8;
        }

        const entriesContainer = document.getElementById('entries');
        const spinButton = document.getElementById('spinButton');
        const spinCountInput = document.getElementById('spinCount');
        const spinDurationInput = document.getElementById('spinDuration');
        const confettiContainer = document.getElementById('confettiContainer');
        const resultModal = document.getElementById('resultModal');
        const finalResultText = document.getElementById('finalResultText');

        let entries = [];
        let isSpinning = false;
        let lastHighlightedSliceIndex = -1;
        let currentRotationOffset = 0; // 追蹤轉盤當前絕對的旋轉角度，以度為單位

        const colors = [
            '#FF6347', '#4682B4', '#3CB371', '#FFD700', '#DA70D6',
            '#FFA07A', '#6A5ACD', '#7FFFD4', '#CD5C5C', '#F08080',
            '#87CEFA', '#90EE90', '#FFB6C1', '#DDA0DD', '#FFE4B5',
            '#ADD8E6', '#98FB98', '#FFC0CB', '#808000', '#A52A2A'
        ];

        function addEntry(defaultText = '', defaultValue = 10) {
            const index = entries.length;
            const newEntry = {
                value: defaultValue,
                text: defaultText,
                id: `entry-${Date.now()}-${index}`
            };
            entries.push(newEntry);
            renderEntry(newEntry);
            drawWheel();
        }

        function renderEntry(entry) {
            const entryDiv = document.createElement('div');
            entryDiv.className = 'entry-item';
            entryDiv.id = entry.id;

            entryDiv.innerHTML = `
                <label>數值:</label>
                <input type="number" min="1" value="${entry.value}" onchange="updateEntry('${entry.id}', 'value', this.value)">
                <label>文字:</label>
                <input type="text" value="${entry.text}" onchange="updateEntry('${entry.id}', 'text', this.value)">
                <button onclick="removeEntry('${entry.id}')">刪除</button>
            `;
            entriesContainer.appendChild(entryDiv);
        }

        function updateEntry(id, type, value) {
            const entryIndex = entries.findIndex(e => e.id === id);
            if (entryIndex > -1) {
                if (type === 'value') {
                    entries[entryIndex].value = Math.max(1, parseInt(value) || 1);
                } else if (type === 'text') {
                    entries[entryIndex].text = value;
                }
                drawWheel();
            }
        }

        function removeEntry(id) {
            if (entries.length <= 1) {
                alert("至少需要保留一個轉盤區域！");
                return;
            }
            entries = entries.filter(e => e.id !== id);
            document.getElementById(id).remove();
            drawWheel();
        }

        function drawWheel(highlightIndex = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const totalValue = entries.reduce((sum, entry) => sum + entry.value, 0);
            if (totalValue === 0) {
                return;
            }

            // 指針在頂部，對應 Canvas 上的 -0.5 * Math.PI (或 270 度)
            // 扇區繪製從這個角度開始，然後順時針。
            let currentAngleRad = -0.5 * Math.PI; 

            entries.forEach((entry, i) => {
                const angleRad = (entry.value / totalValue) * Math.PI * 2; // 扇區角度（弧度）
                const color = colors[i % colors.length];

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngleRad, currentAngleRad + angleRad);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (i === highlightIndex) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngleRad, currentAngleRad + angleRad);
                    ctx.closePath();
                    ctx.strokeStyle = 'gold';
                    ctx.lineWidth = 8;
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(centerX, centerY);
                
                // 計算文字的旋轉角度：扇區的中心角度 + 額外 90 度，使文字垂直顯示
                // 因為扇區是從 -90 度開始繪製的，所以中心點就是 (currentAngleRad + angleRad / 2)
                // 為了讓文字是「朝下」的，我們需要在這個基礎上再加 90 度 (Math.PI / 2)
                ctx.rotate(currentAngleRad + angleRad / 2 + Math.PI / 2); 
                
                ctx.textAlign = "center"; 
                ctx.fillStyle = "white";

                let baseFontSize = radius * 0.08;
                let fontSize = Math.min(baseFontSize, 20);

                ctx.font = `bold ${fontSize}px Arial`;
                let textWidth = ctx.measureText(entry.text).width;
                const maxTextLength = radius * 0.6; 
                while (textWidth > maxTextLength && fontSize > (radius * 0.03)) {
                    fontSize--;
                    ctx.font = `bold ${fontSize}px Arial`;
                    textWidth = ctx.measureText(entry.text).width;
                }
                ctx.fillText(entry.text, 0, -radius * 0.7); 
                ctx.restore();

                currentAngleRad += angleRad; // 更新下一個扇區的起始角度
            });
        }

        function spinWheel() {
            if (isSpinning) return;

            const totalValue = entries.reduce((sum, entry) => sum + entry.value, 0);
            if (totalValue === 0 || entries.some(entry => entry.value <= 0)) {
                alert("請至少設定一個區域，且所有區域的數值必須大於零！");
                return;
            }

            isSpinning = true;
            spinButton.disabled = true;
            removeHighlight();
            closeModal();

            const spinCount = parseInt(spinCountInput.value) || 5;
            const spinDuration = parseFloat(spinDurationInput.value) || 5;

            // 計算每個區塊的起始角度和結束角度（以度為單位，相對指針頂部 0 度順時針）
            const segmentAnglesDegrees = []; // 每個扇區的弧度
            let cumulativeAngle = 0; // 累積角度
            const sectorData = []; // 儲存每個扇區的 (start, end, index)

            entries.forEach((entry, i) => {
                const angle = (entry.value / totalValue) * 360; // 扇區角度（度）
                const startAngle = cumulativeAngle;
                const endAngle = cumulativeAngle + angle;
                sectorData.push({ start: startAngle, end: endAngle, index: i });
                segmentAnglesDegrees.push(angle);
                cumulativeAngle += angle;
            });

            // 隨機選擇一個目標區塊的索引
            let randomValue = Math.random() * totalValue;
            let targetIndex = -1;
            let currentCumulativeValue = 0;
            for (let i = 0; i < entries.length; i++) {
                currentCumulativeValue += entries[i].value;
                if (randomValue < currentCumulativeValue) {
                    targetIndex = i;
                    break;
                }
            }

            // 計算目標區塊的中心角度（以度為單位，從轉盤頂部0度順時針）
            // 這是指針應該對準的轉盤上的角度
            let targetCenterAngleOfSegment = 0;
            for (let i = 0; i < targetIndex; i++) {
                targetCenterAngleOfSegment += segmentAnglesDegrees[i];
            }
            targetCenterAngleOfSegment += segmentAnglesDegrees[targetIndex] / 2;

            // **修正核心：計算最終的停止角度**
            // 
            // 1. 指針固定在轉盤的「頂部中央」。
            // 2. 轉盤繪製時，0度角在右側，頂部指針對應 Canvas 的 -90度 (或 270度)。
            // 3. 我們希望轉盤旋轉後，選中的區塊中心 (targetCenterAngleOfSegment) 能夠轉到指針的位置。
            // 
            // 讓指針指向目標區塊的中心點。
            // 考慮到指針在頂部（0度），轉盤繪製時 0 度是右邊。
            // 我們需要轉動轉盤，使得 `targetCenterAngleOfSegment` (以右側為0度計算的) 最終落在指針下方，也就是 90 度的位置。
            // 或者，等價地說，讓指針（0度）與目標區塊中心對齊。
            // 目標：轉盤最終停止時，讓 `targetCenterAngleOfSegment` 對準指針。
            // 轉盤會逆時針旋轉。
            // 例如：如果目標區塊中心在 45 度 (右偏)，我們需要轉動轉盤 `-(45)` 度才能讓它對準指針。
            // 然後加上多圈數。

            // 最終的停止角度（以度為單位），這是 CSS transform 實際會應用到的角度。
            // 這個角度是從轉盤當前靜止位置 (currentRotationOffset) 加上需要的額外旋轉量。
            // 額外旋轉量 = (旋轉圈數 * 360) + (讓目標區塊對準指針的精確度數)
            // 讓目標區塊中心對準指針的精確度數 = 360 - (targetCenterAngleOfSegment + 90) % 360 + (360 - (targetCenterAngleOfSegment + currentRotationOffset) % 360) % 360
            // 更簡潔且正確的計算方式：
            // 需要旋轉的角度 = (旋轉圈數 * 360) + (使目標區塊中心對準指針的角度)。
            // 指針在轉盤 0 度 (上方)。
            // 我們希望轉盤旋轉到 `targetCenterAngleOfSegment` 落在 0 度。
            // 也就是轉盤要轉動 `(360 - targetCenterAngleOfSegment)` 度。
            // 例如：目標區塊中心在 45 度。轉盤要轉 315 度才會停在指針。
            // 我們要考慮當前轉盤的起始偏移。
            // 最終目標旋轉角度 (絕對值)
            // 目標是讓 `targetCenterAngleOfSegment` 對準 0 度（指針位置）。
            // 則需要轉動 (360 - targetCenterAngleOfSegment) 度。
            // 再加上多圈數。
            let rotationNeededForAlignment = (360 - targetCenterAngleOfSegment) % 360;

            // 考慮到 currentRotationOffset，如果 currentRotationOffset 已經使得 alignment 不足，則需要補足。
            // 這裡直接計算一個絕對的總轉動角度，確保每次都從視覺上的當前位置開始轉。
            // 我們希望最終停在一個角度 `X`，使得 `X % 360` 對應到 `rotationNeededForAlignment`。
            // 總轉動 = 當前累積角度 + 至少多轉 `spinCount` 圈 + 額外精準停止角度
            let finalRotationDegrees = currentRotationOffset + (spinCount * 360) + rotationNeededForAlignment;

            // 如果計算出的 `finalRotationDegrees` 比 `currentRotationOffset` 還小，說明我們算錯了或少了一圈
            // 這是為了處理 `currentRotationOffset` 已經超過 `rotationNeededForAlignment` 的情況
            // 例如 currentRotationOffset=300, rotationNeededForAlignment=10
            // finalRotation = 300 + 5*360 + 10 = 2110
            // 2110 % 360 = 310 (結果不是 10)
            // 我們需要確保最終停止角度 `finalRotationDegrees` 模 360 後，能夠落在 `rotationNeededForAlignment`。
            // 最簡單的做法是，確保 `finalRotationDegrees` 比 `currentRotationOffset` 至少大 `360` 度。
            // 確保旋轉至少一圈以上：
            while (finalRotationDegrees <= currentRotationOffset + 360) {
                finalRotationDegrees += 360;
            }


            // 清除之前的 transition 樣式，並立即設定為當前視覺上的角度
            canvas.style.transition = 'none'; 
            canvas.style.transform = `rotate(${currentRotationOffset}deg)`;
            
            void canvas.offsetWidth; // 強制瀏覽器重繪

            const easeOutCubicBezier = 'cubic-bezier(0.1, 0.5, 0, 1)'; 

            canvas.style.setProperty('--spin-duration', `${spinDuration}s`);
            canvas.style.setProperty('--end-rotation', `${finalRotationDegrees}deg`);

            // 重新添加 transition 屬性，並應用新的動畫曲線
            canvas.style.transition = `transform var(--spin-duration) ${easeOutCubicBezier}`;
            canvas.style.transform = `rotate(${finalRotationDegrees}deg)`;

            // 使用 setTimeout 確保動畫完成後執行邏輯
            setTimeout(() => {
                isSpinning = false;
                spinButton.disabled = false;
                
                // 計算最終停止時，轉盤相對於指針的實際角度 (0-360度)
                // 指針在 0 度，轉盤轉動 `finalRotationDegrees` 度後，
                // 我們要看指針指向哪個區塊。
                // 實際的轉盤停止角度 (模 360)
                let actualStopAngle = finalRotationDegrees % 360;
                if (actualStopAngle < 0) actualStopAngle += 360;

                // 找到與 `actualStopAngle` 對應的區塊
                let winningIndex = -1;
                let currentAngleForWinningCheck = 0; // 以 0 度為起始，順時針計算
                for (let i = 0; i < sectorData.length; i++) {
                    const sector = sectorData[i];
                    // 指針指向 0 度，我們要找到 0 度落在哪個扇區的範圍內
                    // 注意：扇區範圍是 [start, end)
                    // 如果指針指向 0 度，那麼我們需要找到一個扇區，其範圍包含 (360 - actualStopAngle + 0) % 360
                    // 這裡的邏輯是反過來的：我們知道轉盤最終停在哪個絕對角度，
                    // 然後看這個絕對角度與每個區塊的相對位置。
                    // 為了方便判斷，我們可以將指針的「0度」位置看作是目標區塊的中點。
                    // 或者，更直接地，將 `actualStopAngle` 進行偏移，使其與扇區的繪製角度基準一致。
                    
                    // 最簡單的方式是：將 `actualStopAngle` 逆轉回來，看它落在哪個區塊的範圍內。
                    // 因為轉盤是逆時針旋轉的，所以指針指向的是轉盤的 "actualStopAngle" 角度。
                    // 但是我們的扇區是從指針位置 (0度) 順時針繪製的。
                    // 所以我們需要計算出指針所指的「相對扇區角度」。
                    
                    // 指針的絕對位置是 0 度 (正上方)。
                    // 轉盤最終停在 `actualStopAngle` 度。
                    // 我們需要將 `actualStopAngle` 反轉過來，才能與扇區的順時針角度對應。
                    // 例如，轉盤轉了 315 度，停在 315 度。指針在 0 度。
                    // 那麼指針其實是落在轉盤的 (0 - 315) = -315 = 45 度位置。
                    // 因此，指針所指的相對角度是 (360 - actualStopAngle) % 360。
                    let pointerRelativeAngle = (360 - actualStopAngle + 360) % 360; // 確保為正值

                    if (pointerRelativeAngle >= sector.start && pointerRelativeAngle < sector.end) {
                        winningIndex = sector.index;
                        break;
                    }
                }

                const resultText = entries[winningIndex].text;

                highlightSlice(winningIndex);
                lastHighlightedSliceIndex = winningIndex;

                showResultModal(resultText);
                throwConfetti();

                // 更新 currentRotationOffset 為實際停止的絕對角度，用於下一次旋轉的起始點
                currentRotationOffset = actualStopAngle; 
                canvas.style.transform = `rotate(${currentRotationOffset}deg)`;
                canvas.style.transition = 'none'; // 移除 transition 樣式，防止回到原始狀態
                
            }, spinDuration * 1000);
        }

        function highlightSlice(index) {
            drawWheel(index);
        }

        function removeHighlight() {
            if (lastHighlightedSliceIndex !== -1) {
                drawWheel();
                lastHighlightedSliceIndex = -1;
            }
        }

        function throwConfetti() {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722', '#795548', '#9e9e9e', '#607d8b'];
            const numConfetti = 100;

            for (let i = 0; i < numConfetti; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                confettiContainer.appendChild(confetti);

                confetti.addEventListener('animationend', () => {
                    confetti.remove();
                });
            }
        }

        function showResultModal(resultText) {
            finalResultText.textContent = resultText;
            resultModal.style.display = 'flex';
        }

        function closeModal() {
            resultModal.style.display = 'none';
        }

        function initializeEntries() {
            addEntry('恭喜發財', 20);
            addEntry('事事順利', 30);
            addEntry('學業進步', 25);
            addEntry('天天開心', 25);
        }

        spinButton.addEventListener('click', spinWheel);
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && resultModal.style.display === 'flex') {
                closeModal();
            }
        });
        window.addEventListener('click', (event) => {
            if (event.target === resultModal) {
                closeModal();
            }
            // 避免點擊模態框內容關閉模態框
            if (event.target === resultModal && event.target !== document.getElementById('finalResultText') && event.target !== document.querySelector('.modal-button')) {
                closeModal();
            }
        });


        window.addEventListener('resize', () => {
            setCanvasDimensions();
            drawWheel();
        });

        // 頁面加載完成後執行初始化
        window.onload = () => {
            setCanvasDimensions();
            initializeEntries();
        };
    </script>

</body>
</html>
